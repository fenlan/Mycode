/****************************************************************************
汉诺塔的递归实现算法，将A中的圆盘借助B圆盘完全移动到C圆盘上，
每次只能移动一个圆盘，并且每次移动时大盘不能放在小盘上面
递归函数的伪算法为如下:
if(n == 1)
   直接将A柱子上的圆盘从A移动到C
else
   先将A柱子上的n-1个圆盘借助C柱子移动到B柱子上
   直接将A柱子上的第n个圆盘移动到C柱子上
   最后将B柱子上的n-1个圆盘借助A柱子移动到C柱子上

该递归算法的时间复杂度为O（2的n次方)，当有n个圆盘时，需要移动圆盘2的n次方-1次
****************************************************************************/

#include<stdio.h>

void move(int,char,char,char);

int main()
{ 	
	//A、B、C分别代表三个柱子
	char ch1 = 'A';
	char ch2 = 'B'; 
	char ch3 = 'C'; 

	//n代表圆盘的个数
	int n;
	printf("请输入圆盘个数：");
	scanf("%d",&n);
	move(n,ch1,ch2,ch3);

	return 0;
}

/*
将n个圆盘从x柱子借助y柱子移动到z柱子上
*/
void move(int n,char x,char y,char z)
{
	if(n == 1)
	   printf("圆盘编号%d：从%c移动到%c\n",n,x,z);
	else
	{
	   move(n-1,x,z,y);
	   printf("圆盘编号%d：从%c移动到%c\n",n,x,z);
	   move(n-1,y,x,z);
	}
}
